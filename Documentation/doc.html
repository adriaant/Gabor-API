<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="author" content="Adriaan Tijsseling" />
  <meta name="copyright" content="Creative Commons Attribution-NonCommercial-NoDerivs 2.5 License" />
  <meta name="robots" content="all" />
  <title>infinite-sushi.com: Gabor API</title>
  <link rel="stylesheet" type="text/css" media="screen" href="http://infinite-sushi.com/styles/basic.css" />
  <link rel="shortcut icon" href="http://infinite-sushi.com/favicon.ico" type="image/x-icon" />
  <script type="text/javascript" src="http://infinite-sushi.com/scripts/global.js"></script>
</head>
<body>

<h2>Gabor API</h2>

<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#3">Installation</a></li>
<li><a href="#4">Quickstart</a></li>
<li><a href="#5">Usage</a></li>
<li><a href="#6">References</a></li>
</ul>

<a name="1"></a>
<h3>Introduction</h3>

<p>
The Gabor-API is a C++ code library implementation of Gabor Filters. This code is courtesy of the <a href="http://www.neurosci.aist.go.jp/~mechwa/">MECHwA Team</a>. The API provides the necessary routines for the user to apply Gabor filters to images in .PGM format. Optionally, contrast filters and log-polar transform can be applied to the image before Gabor convolution. Additionally, the library comes in two variants. The first variant implements the standard Gabor filter method in which an image is convoluted with a lattice of possibly overlapping banks of Gabor filters at different orientations and frequencies. The second variant convolutes banks of Gabor filters at so-called fiducial points in an image. The coordinations of these fiducial points are supplied in a text file.
</p>

<a name="3"></a>
<h3>Installation</h3>
<p>
Unpack the downloaded tar.gz file in the directory of your choosing. To compile the library, navigate to the desired subdirectory <code class="yellow">gabor-global/src/</code> (for the standard Gabor implementation) or <code class="yellow">gabor-local/src/</code> (for the fiducial implementation) and just issue a <code class="green">make</code> command. The Makefile located in <code class="yellow">gabor-global/</code> and <code class="yellow">gabor-local/</code> will compile an executable based on the library and the <code class="yellow">Gabor.cpp</code> file, but it needs to be modified first by changing the listed <code class="yellow">bin/</code> directory, in which the compiled executables will be installed. If you are using Project Builder, you will also need to modify the working directory in the Custom Build Command Settings of the four available build targets.
</p><p>
In addition, the <code class="yellow">Sample Files/</code> directory contains test images and a text file containing fiducial points. 
</p>

<a name="4"></a>
<h3>Quickstart</h3>
<p>
As a quickstart, <code class="green">cd</code> to the <code class="yellow">Sample Files/</code> directory and run the sample command:</p>
<pre class="green">
gaborglobal -X 8 -Y 8 -x 2 -y 2 -s 3 -a 6 -f 4 -l 0.25 -u 1.5 -v 0 -S 1 lena.ppm
</pre>
<p>or:</p>
<pre class="green">
gaborlocal -s 15 -a 4 -f 2 -l 0.5 -u 0.75 -r 10 -v 0 -S 1 -F face-fiducials.txt face.ppm
</pre>
<p>
Pass a <code class="green">-h</code> flag to the executable for an explanation of the command line options. Naturally, a variety of parameter ranges is possible, depending on the nature of the image, the size and spacing of gabor filters, and so on. If the <code class="green">-S</code> flag is set to 1, then the gabor filters are themselves saved as images. These images will give a good idea how to change the values for the sigma modulator and the frequencies to get an optimal setting. It is a good idea to play with these values and observe the changes in the produced images.
</p><p>
When using the fiducial implementation of Gabor filters, a file containing the coordinates of the fiducial points must be passed as a mandatory <code class="green">-F</code> argument to the executable. This text file should have the number of fiducials listed in the first row, with  subsequent rows containing the x and y coordinates. For example:
</p>
<pre>
# comments follow a hedge. The rest of the line is ignored.
4	# the number of fiducial points
# following is a list of coordinates
186	84
147	111
219	112
150	148
</pre>

<a name="5"></a>
<h3>Usage</h3>
<p>
<code class="red">&#8658;</code>&nbsp;To use the library as part of a code project, write an interface file containing a function that receives the image data and returns a vector with the Gabor filter responses. For example, if the image data is piped from a camera capture into a vector of RGB value integers, then pass this vector, along with the dimensions of the image and a pointer to an integer holding the length of the response vector to a function:
</p><pre class="green">
float *ProcessImageData( int* rgb, int h, int w, int* respLen )
</pre>
<p>
In this function, convert the integer vector into a matrix of floats and call the function
</p>
<pre class="green">
float* ProcessChannel( float** image, int h, int w, float* response, int* len )
</pre>
<p>which is already defined in the <code class="yellow">Gabor.cpp</code> files included in the archive. The <code class="green">ProcessImageData()</code> function could be defined as:</p>
<pre>
float *ProcessImageData( int *rgb, int h, int w, int* respLen )
{
    int     i, j, k = 0;
    float*  response = NULL;
    float   norm, max, min;
    
// allocate pixels for rgb matrix
    float** pixels = CreateMatrix( (float)255.0, h, w );

// in this example, we convert to grayscale
    for ( i = 0; i &lt; h; i++ )
    {
        for ( j = 0; j &lt; w; j++ )
        {
            pixels[i][j] = sqrt( (float)(
                                  rgb[k]*rgb[k] +
                                  rgb[k+1]*rgb[k+1] +
                                  rgb[k+2]*rgb[k+2] ) ) / sqrt( 3.0 );
            k = k + 3;
        }
    }

// process grayscale pixels, get gabor filter response length
// and allocate the to be returned vector
    *respLen = 0;
    response = ProcessChannel( pixels, h, w, response, respLen );
    
// scale the responses to 0 and 1
    max = min = response[0];
    for ( i = 1; i &lt; *respLen; i++ )
    {
        if( response[i] &gt; max ) max = response[i];
        if( response[i] &lt; min ) min = response[i];
    }
    norm = max - min;
    for ( i = 0; i &lt; *respLen; i++ )
        response[i] = 1.0 * ( ( response[i] - min ) / norm );

// make sure to clean up the pixel buffer
    DisposeMatrix( pixels, h );

// the response vector needs to be disposed by the caller
    return response;
}
</pre>

<p>In the main code, this function could be called as follows:</p>
<pre>
float *response = NULL;
int   *frameBuf = new int[Xdim*Ydim*3];
int   len;
CaptureCamera( frameBuf );
response = ProcessImageData( frameBuf, Ydim, Xdim, &amp;len );
// do something nice with response
delete[] response;
delete[] frameBuf;
</pre>
<p>
The <code class="green">ProcessChannel()</code> function implemented in the <code class="yellow">Gabor.cpp</code> files does not require any modification and can be used as is. It is, however, well commented and easy to understand, so that it allows for straightforward adjustment according to user directions. 
</p>
<p><code class="red">&#8658;</code>&nbsp;Please observe the following defines:
</p><p>
In <code class="yellow">gabor-global/src/GaborJet.h</code>: <code class="cyan">kAngleSeparation</code>.<br />
If set to 1, collecting the Gabor filter responses occurs by iterating over angles and frequencies, producing a response vector the length of the product of the sum of angles and the sum of frequencies. It will also generate filtered images for each angle-frequency combination. When set to 0, iteration is over all filter locations, averaging the angle and frequency responses. The length of the response vector in this case is the sum of Gabor filter banks.  Only one filtered image is produced. 
</p><p>
In <code class="yellow">Gabor.cpp</code>: <code class="cyan">kUseLogPolar</code>, <code class="cyan">kUseContrast</code>, <code class="cyan">kUsingColor</code><br />
The first two defines determine whether to apply the Log-Polar transform and/or the Contrast filter. In case of the fiducial implementation, the Log-Polar transform does not apply. Alternatively, one can also specify whether an image's red, green, and blue channels will be filtered separately, or whether the RGB values are first converted to grayscale (default).
</p>

<a name="6"></a>
<h3>References</h3>
<ul>
<li>Atick &amp; Redlich, "<a href="http://www.klab.caltech.edu/~pam/nnss/atick8.html">What does the retina know about natural scenes?</a>", <i>Neural Computation</i> 4(2), pp. 196-210, 1992. [Background on the contrast filter]</li>
<li><a href="http://www.htlab.ice.uec.ac.jp/~hotta/">Hotta</a>, <a href="http://staff.aist.go.jp/takio-kurita/index.html">Kurita</a> &amp; Mishima, "Scale invariant face recognition method using spectral features of log-polar image", <i>SPIE'99 Conference: Applications of Digital Image Processing XXII</i>, 1999.</li>
<li><a href="http://www.htlab.ice.uec.ac.jp/~hotta/">Hotta</a>, Mishima, <a href="http://staff.aist.go.jp/takio-kurita/index.html">Kurita</a> &amp; Umeyama, "<a href="http://citeseer.nj.nec.com/hotta00face.html">Face matching through information theoretical attention points and its applications to face detection and classification</a>", <i>Fourth IEEE International Conference on Automatic Face and Gesture Recognition</i>, pp.34-39, Grenoble, France, March 28-30, 2000.</li>
<li><a href="http://www.pspc.dibe.unige.it/~neuroinfo/sandini.html">Sandini</a> &amp; Tagliasco, "An anthropomorphic retina-like structure for scene analyisis", <i>Computer Graphics and Image Processing</i> 14, pp. 365-372, 1980. [Background on the log-polar transform]</li>
<li>Turner, M.R. "Texture discrimination by Gabor functions", <i>Biological Cybernetics</i> 55, pp. 71-82, 1986. [Excellent paper on Gabor filters]</li>
</ul>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-1599194-1";
urchinTracker();
</script>
</body>
</html>
